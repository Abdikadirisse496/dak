#!/usr/bin/env python

# Create all the Release files

# Copyright (C) 2001  Anthony Towns <ajt@debian.org>
# $Id: ziyi,v 1.13 2001-11-27 04:15:14 rmurray Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#   ``Bored now''

################################################################################

import pg, sys, os, stat, string, time
import utils, db_access
import apt_pkg

################################################################################

Cnf = None
projectB = None

################################################################################

def usage (exit_code=0):
    print """Usage: ziyi [OPTION]
Generate Release files.

  -h, --help                 show this help and exit"""

    sys.exit(exit_code)

################################################################################

def compressnames (tree,type,file):
    compress = AptCnf.get("%s::%s::Compress" % (tree,type), AptCnf.get("Default::%s::Compress" % (type), ". gzip"))
    result = []
    for mode in string.split(compress):
	if mode == ".":
	    result.append(file)
	elif mode == "gzip":
	    result.append(file + ".gz")
	elif mode == "bzip2":
	    result.append(file + ".bz2")
    return result

def print_md5_files (tree, files):
    path = Cnf["Dir::RootDir"] + tree + "/"
    for name in files:
        try:
            file_handle = utils.open_file(path + name)
        except utils.cant_open_exc:
            print "ALERT: Couldn't open " + path + name
        else:
	    md5 = apt_pkg.md5sum(file_handle)
	    file_handle.close()

        size = os.stat(path + name)[stat.ST_SIZE]
        out.write(" %s         %8d %s\n" % (md5, size, name))

def print_sha1_files (tree, files):
    path = Cnf["Dir::RootDir"] + tree + "/"
    for name in files:
        try:
            file_handle = utils.open_file(path + name)
        except utils.cant_open_exc:
            print "ALERT: Couldn't open " + path + name
        else:
	    sha1 = apt_pkg.sha1sum(file_handle)
	    file_handle.close()

        size = os.stat(path + name)[stat.ST_SIZE]
        out.write(" %s %8d %s\n" % (sha1, size, name))

################################################################################

def main ():
    global Cnf, AptCnf, projectB, out
    out = sys.stdout;

    Cnf = utils.get_conf()

    AptCnf = apt_pkg.newConfiguration()
    apt_pkg.ReadConfigFileISC(AptCnf,utils.which_apt_conf_file())

    Arguments = [('h',"help","Ziyi::Options::Help")];
    for i in [ "help" ]:
	if not Cnf.has_key("Ziyi::Options::%s" % (i)):
	    Cnf["Ziyi::Options::%s" % (i)] = "";

    suites = apt_pkg.ParseCommandLine(Cnf,Arguments,sys.argv)
    Options = Cnf.SubTree("Ziyi::Options")

    if Options["Help"]:
	usage();

    if not suites:
        suites = Cnf.SubTree("Suite").List()

    def real_arch(x):
	return x != "source" and x != "all"

    for suite in suites:
        print "Processing: " + suite
	SuiteBlock = Cnf.SubTree("Suite::" + suite)

	if SuiteBlock.has_key("Untouchable"):
            print "Skipping: " + suite + " (untouchable)"
            continue

	suite = string.lower(suite)

	origin = SuiteBlock["Origin"]
	label = SuiteBlock.get("Label", origin)
	version = SuiteBlock.get("Version", "")
	codename = SuiteBlock.get("CodeName", "")

	if SuiteBlock.has_key("NotAutomatic"):
	    notautomatic = "yes"
	else:
	    notautomatic = ""

	if SuiteBlock.has_key("Components"):
	    components = SuiteBlock.SubTree("Components").List()
	else:
	    components = []

	nonus = 1
	if components != []:
	    for c in components:
	        if string.find(c, "non-US/") != 0:
		    nonus = 0
	else:
	    nonus = 0
	if nonus:
	    longsuite = suite + "/non-US"
	else:
	    longsuite = suite

	tree = SuiteBlock.get("Tree", "dists/%s" % (longsuite))

	if AptCnf.has_key("tree::%s" % (tree)):
	    pass
	elif AptCnf.has_key("bindirectory::%s" % (tree)):
	    pass
	else:
	    print "ALERT: suite %s not in apt.conf, nor untouchable!" % (suite)
	    continue

	print Cnf["Dir::RootDir"] + tree + "/Release"
	out = open(Cnf["Dir::RootDir"] + tree + "/Release", "w")

	out.write("Origin: %s\n" % (origin))
	out.write("Label: %s\n" % (label))
	out.write("Suite: %s\n" % (suite))
	if version != "":
	    out.write("Version: %s\n" % (version))
	if codename != "":
	    out.write("Codename: %s\n" % (codename))
	out.write("Date: %s\n" % (time.strftime("%a, %d %b %Y %H:%M:%S UTC", time.gmtime(time.time()))))
	if notautomatic != "":
	    out.write("NotAutomatic: %s\n" % (notautomatic))
	out.write("Architectures: %s\n" % (string.join(filter(real_arch, SuiteBlock.SubTree("Architectures").List()))))
	if components != []:
            out.write("Components: %s\n" % (string.join(components)))

	out.write("Description: %s\n" % (SuiteBlock["Description"]))

	files = []

	if AptCnf.has_key("tree::%s" % (tree)):
	    for sec in string.split(AptCnf["tree::%s::Sections" % (tree)]):
		for arch in string.split(AptCnf["tree::%s::Architectures" % (tree)]):
		    if arch == "source":
			for file in compressnames("tree::%s" % (tree), "Sources", "%s/%s/Sources" % (sec, arch)):
			    files.append(file)
		    else:
			disks = "%s/disks-%s" % (sec, arch)
			diskspath = Cnf["Dir::RootDir"]+tree+"/"+disks
			if os.path.exists(diskspath):
			    for dir in os.listdir(diskspath):
				if os.path.exists("%s/%s/md5sum.txt" % (diskspath, dir)):
				    files.append("%s/%s/md5sum.txt" % (disks, dir))

			for file in compressnames("tree::%s" % (tree), "Packages", "%s/binary-%s/Packages" % (sec, arch)):
			    files.append(file)

		    if arch == "source":
			rel = "%s/%s/Release" % (sec, arch)
		    else:
			rel = "%s/binary-%s/Release" % (sec, arch)
		    relpath = Cnf["Dir::RootDir"]+tree+"/"+rel

		    if os.path.exists(relpath):
			try:
			    release = open(relpath, "w")
			    #release = open(string.replace(longsuite,"/","_") + "_" + arch + "_" + sec + "_Release", "w")
			except IOError:
			    print "Couldn't write to " + relpath
			else:
			    release.write("Archive: %s\n" % (suite))
			    if version != "":
				release.write("Version: %s\n" % (version))
			    if nonus:
				release.write("Component: non-US/%s\n" % (sec))
			    else:
				release.write("Component: %s\n" % (sec))
			    release.write("Origin: %s\n" % (origin))
			    release.write("Label: %s\n" % (label))
			    if notautomatic != "":
				release.write("NotAutomatic: %s\n" % (notautomatic))
			    release.write("Architecture: %s\n" % (arch))
			    release.close()
			    files.append(rel)

	    if AptCnf.has_key("tree::%s/main" % (tree)):
	        sec = string.split(AptCnf["tree::%s/main::Sections" % (tree)])[0]
		if sec != "debian-installer":
	    	    print "ALERT: weird non debian-installer section in %s" % (tree)

		for arch in string.split(AptCnf["tree::%s/main::Architectures" % (tree)]):
		    if arch != "source":  # always true
			for file in compressnames("tree::%s/main" % (tree), "Packages", "main/%s/binary-%s/Packages" % (sec, arch)):
			    files.append(file)

	elif AptCnf.has_key("bindirectory::%s" % (tree)):
	    for file in compressnames("bindirectory::%s" % (tree), "Packages", AptCnf["bindirectory::%s::Packages" % (tree)]):
		files.append(string.replace(file,tree+"/","",1))
	    for file in compressnames("bindirectory::%s" % (tree), "Sources", AptCnf["bindirectory::%s::Sources" % (tree)]):
		files.append(string.replace(file,tree+"/","",1))
	else:
	    print "ALERT: no tree/bindirectory for %s" % (tree)

	out.write("MD5Sum:\n")
	print_md5_files(tree, files)
	out.write("SHA1:\n")
	print_sha1_files(tree, files)

	out.close()
	if Cnf.has_key("Dinstall::SigningKeyring"):
	    dest = Cnf["Dir::RootDir"] + tree + "/Release.gpg"
	    if os.path.exists(dest):
		os.unlink(dest)
	    keyring = "--secret-keyring \"%s\"" % Cnf["Dinstall::SigningKeyring"]
	    if Cnf.has_key("Dinstall::SigningPubKeyring"):
		keyring = keyring + " --keyring \"%s\"" % Cnf["Dinstall::SigningPubKeyring"])

	    os.system("gpg %s --no-options --batch --no-tty --armour --detach-sign <%s --output=%s" % (keyring,
		Cnf["Dir::RootDir"] + tree + "/Release", dest))

#######################################################################################

if __name__ == '__main__':
    main()

