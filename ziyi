#!/usr/bin/env python

# Create all the Release files

# Copyright (C) 2001  Anthony Towns <ajt@debian.org>
# $Id: ziyi,v 1.5 2001-04-24 05:16:22 ajt Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#   ``Bored now''

################################################################################

import pg, sys, os, stat, string, time
import utils, db_access
import apt_pkg

################################################################################

Cnf = None
projectB = None

################################################################################

def compressnames (tree,type,file):
    compress = AptCnf.get("%s::%s::Compress" % (tree,type), AptCnf.get("Default::%s::Compress" % (type), ". gzip"))
    result = []
    for mode in string.split(compress):
	if mode == ".":
	    result.append(file)
	elif mode == "gzip":
	    result.append(file + ".gz")
	elif mode == "bzip2":
	    result.append(file + ".bz2")
    return result

def print_md5_files (tree, files):
    path = Cnf["Dir::RootDir"] + tree + "/"
    for name in files:
        try:
            file_handle = utils.open_file(path + name, "r")
        except utils.cant_open_exc:
            print "ALERT: Couldn't open " + path + name
        else:
	    md5 = apt_pkg.md5sum(file_handle)
	    file_handle.close()

        size = os.stat(path + name)[stat.ST_SIZE]
        out.write(" %s         %8d %s\n" % (md5, size, name))

def print_sha1_files (tree, files):
    path = Cnf["Dir::RootDir"] + tree + "/"
    for name in files:
        try:
            file_handle = utils.open_file(path + name, "r")
        except utils.cant_open_exc:
            print "ALERT: Couldn't open " + path + name
        else:
	    sha1 = apt_pkg.sha1sum(file_handle)
	    file_handle.close()

        size = os.stat(path + name)[stat.ST_SIZE]
        out.write(" %s %8d %s\n" % (sha1, size, name))

################################################################################

def main ():
    global Cnf, AptCnf, projectB, out
    out = sys.stdout;


    apt_pkg.init()
    
    Cnf = apt_pkg.newConfiguration()
    apt_pkg.ReadConfigFileISC(Cnf,utils.which_conf_file())

    AptCnf = apt_pkg.newConfiguration()
    apt_pkg.ReadConfigFileISC(AptCnf,utils.which_apt_conf_file())
    print "APT.CONF IS: " + utils.which_apt_conf_file()

    Arguments = [('d',"debug","Ziyi::Options::Debug", "IntVal"),
                 ('h',"help","Ziyi::Options::Help"),
                 ('v',"version","Ziyi::Options::Version")]

    suites = apt_pkg.ParseCommandLine(Cnf,Arguments,sys.argv)

    if suites == []:
        suites = Cnf.SubTree("Suite").List()

    def real_arch(x):
	return x != "source" and x != "all"

    for suite in suites:
        print "Processing: " + suite
	SuiteBlock = Cnf.SubTree("Suite::" + suite)

	if SuiteBlock.has_key("Untouchable"):
            print "Skipping: " + suite + " (untouchable)"
            continue

	suite = string.lower(suite)

	origin = SuiteBlock["Origin"]
	label = SuiteBlock.get("Label", origin)
	version = SuiteBlock.get("Version", "")
	codename = SuiteBlock.get("CodeName", "")
	if SuiteBlock.has_key("Components"):
	    components = SuiteBlock.SubTree("Components").List()
	else:
	    components = []

	nonus = 1
	if components != []:
	    for c in components:
	        if c[:7] != "non-US/":
		    nonus = 0
	else:
	    nonus = 0
	if nonus:
	    longsuite = suite + "/non-US"
	else:
	    longsuite = suite

	tree = SuiteBlock.get("Tree", "dists/%s" % (longsuite))

	print Cnf["Dir::RootDir"] + tree + "/Release"
	out = open(Cnf["Dir::RootDir"] + tree + "/Release", "w")

	out.write("Origin: %s\n" % (origin))
	out.write("Label: %s\n" % (label))
	out.write("Suite: %s\n" % (suite))
	if version != "":
	    out.write("Version: %s\n" % (version))
	if codename != "":
	    out.write("Codename: %s\n" % (codename))
	out.write("Date: %s\n" % (time.strftime("%a, %d %b %Y %H:%M:%S UTC", time.gmtime(time.time()))))
	out.write("Architectures: %s\n" % (string.join(filter(real_arch, SuiteBlock.SubTree("Architectures").List()))))
	if components != []:
            out.write("Components: %s\n" % (string.join(components)))

	out.write("Description: %s\n" % (SuiteBlock["Description"]))

	files = []

	if AptCnf.has_key("tree::%s" % (tree)):
	    for sec in string.split(AptCnf["tree::%s::Sections" % (tree)]):
		for arch in string.split(AptCnf["tree::%s::Architectures" % (tree)]):
		    if arch == "source":
			for file in compressnames("tree::%s" % (tree), "Sources", "%s/%s/Sources" % (sec, arch)):
			    files.append(file)
		    else:
			rel = "%s/binary-%s/Release" % (sec, arch)
			relpath = Cnf["Dir::RootDir"]+tree+"/"+rel
			if os.path.exists(relpath):
			    try:
				release = open(relpath, "w")
				#release = open(string.replace(longsuite,"/","_") + "_" + arch + "_" + sec + "_Release", "w")
			    except IOError:
				print "Couldn't write to " + relpath
			    else:
				release.write("Archive: %s\n" % (suite))
				if version != "":
				    release.write("Version: %s\n" % (version))
				if nonus:
				    release.write("Component: non-US/%s\n" % (sec))
				else:
				    release.write("Component: %s\n" % (sec))
				release.write("Origin: %s\n" % (origin))
				release.write("Label: %s\n" % (label))
				release.write("Architecture: %s\n" % (arch))
				release.close()
			    files.append("%s/binary-%s/Release" % (sec,arch))

			disks = "%s/disks-%s" % (sec, arch)
			diskspath = Cnf["Dir::RootDir"]+tree+"/"+disks
			if os.path.exists(diskspath):
			    for dir in os.listdir(diskspath):
				if os.path.exists("%s/%s/md5sum.txt" % (diskspath, dir)):
				    files.append("%s/%s/md5sum.txt" % (disks, dir))

			for file in compressnames("tree::%s" % (tree), "Packages", "%s/binary-%s/Packages" % (sec, arch)):
			    files.append(file)

	    if AptCnf.has_key("tree::%s/main" % (tree)):
	        sec = string.split(AptCnf["tree::%s/main::Sections" % (tree)])[0]
		if sec != "debian-installer":
	    	    print "ALERT: weird non debian-installer section in %s" % (tree)

		for arch in string.split(AptCnf["tree::%s/main::Architectures" % (tree)]):
		    if arch != "source":  # always true
			for file in compressnames("tree::%s/main" % (tree), "Packages", "main/%s/binary-%s/Packages" % (sec, arch)):
			    files.append(file)

	elif AptCnf.has_key("bindirectory::%s" % (tree)):
	    for file in compressnames("bindirectory::%s" % (tree), "Packages", AptCnf["bindirectory::%s::Packages" % (tree)]):
		files.append(string.replace(file,tree+"/","",1))
	    for file in compressnames("bindirectory::%s" % (tree), "Sources", AptCnf["bindirectory::%s::Sources" % (tree)]):
		files.append(string.replace(file,tree+"/","",1))
	else:
	    print "ALERT: no tree/bindirectory for %s" % (tree)

	out.write("MD5Sum:\n")
	print_md5_files(tree, files)
	out.write("SHA1:\n")
	print_sha1_files(tree, files)

	out.close()
	if Cnf.has_key("Dinstall::SigningKeyring"):
	    dest = Cnf["Dir::RootDir"] + tree + "/Release.gpg"
	    if os.path.exists(dest):
		 os.unlink(dest)
	    os.system("gpg --secret-keyring \"%s\" --no-options --batch --no-tty --armour --detach-sign <%s --output=%s" % (Cnf["Dinstall::SigningKeyring"], 
		Cnf["Dir::RootDir"] + tree + "/Release", dest))

#######################################################################################

if __name__ == '__main__':
    main()

