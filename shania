#!/usr/bin/env python

# Clean incoming of old unused files
# Copyright (C) 2000, 2001  James Troup <james@nocrew.org>
# $Id: shania,v 1.11 2002-01-28 18:53:01 troup Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

################################################################################

import os, re, stat, string, sys, time, traceback
import utils
import apt_pkg;

################################################################################

# 23:12|<aj> I will not hush!
# 23:12|<elmo> :>
# 23:12|<aj> Where there is injustice in the world, I shall be there!
# 23:13|<aj> I shall not be silenced!
# 23:13|<aj> The world shall know!
# 23:13|<aj> The world *must* know!
# 23:13|<elmo> oh dear, he's gone back to powerpuff girls... ;-)
# 23:13|<aj> yay powerpuff girls!!
# 23:13|<aj> buttercup's my favourite, who's yours?
# 23:14|<aj> you're backing away from the keyboard right now aren't you?
# 23:14|<aj> *AREN'T YOU*?!
# 23:15|<aj> I will not be treated like this.
# 23:15|<aj> I shall have my revenge.
# 23:15|<aj> I SHALL!!!

################################################################################

Cnf = None;
Options = None;
del_dir = None;

################################################################################

def usage (exit_code=0):
    print """Usage: shania [OPTIONS]
Clean out incoming directories.

  -d, --days=DAYS            remove anything older than DAYS old
  -i, --incoming=INCOMING    the incoming directory to clean
  -n, --no-action            don't do anything
  -v, --verbose              explain what is being done
  -h, --help                 show this help and exit"""

    sys.exit(exit_code)

################################################################################

def init ():
    global delete_date, del_dir;

    delete_date = int(time.time())-(int(Options["Days"])*84600);

    # Ensure a directory exists to remove files to
    if not Options["No-Action"]:
        date = time.strftime("%Y-%m-%d", time.localtime(time.time()));
        del_dir = Cnf["Dir::Morgue"] + '/' + Cnf["Shania::MorgueSubDir"] + '/' + date;
        if not os.path.exists(del_dir):
            os.makedirs(del_dir, 02775);
        if not os.path.isdir(del_dir):
            utils.fubar("%s must be a directory." % (del_dir));

    # Move to the directory to clean
    incoming = Options["Incoming"];
    if incoming == "":
        incoming = Cnf["Dir::IncomingDir"];
    os.chdir(incoming);

# Remove a file to the morgue
def remove (file):
    if os.access(file, os.R_OK):
        dest_filename = del_dir + '/' + os.path.basename(file);
        # If the destination file exists; try to find another filename to use
        if os.path.exists(dest_filename):
            dest_filename = utils.find_next_free(dest_filename, 10);
        utils.move(file, dest_filename);
    else:
        utils.warn("skipping '%s', permission denied." % (os.path.basename(file)));

# Removes any old files.
# [Used for Incoming/REJECT]
#
def flush_old ():
    for file in os.listdir('.'):
        if os.path.isfile(file):
            if os.stat(file)[stat.ST_MTIME] < delete_date:
                if Options["No-Action"]:
                    print "I: Would delete '%s'." % (os.path.basename(file));
                else:
                    if Options["Verbose"]:
                        print "Removing '%s' (to '%s')."  % (os.path.basename(file), del_dir);
                    remove(file);
            else:
                if Options["Verbose"]:
                    print "Skipping, too new, '%s'." % (os.path.basename(file));

# Removes any files which are old orphans (not associated with a valid .changes file).
# [Used for Incoming]
#
def flush_orphans ():
    all_files = {};
    changes_files = [];

    # Build up the list of all files in the directory
    for i in os.listdir('.'):
        if os.path.isfile(i):
            all_files[i] = 1;
            if i[-8:] == ".changes":
                changes_files.append(i);

    # Proces all .changes and .dsc files.
    for changes_filename in changes_files:
        try:
            changes = utils.parse_changes(changes_filename, 0)
            files = utils.build_file_list(changes, "");
        except:
            utils.warn("error processing '%s'; skipping it. [Got %s]" % (changes_filename, sys.exc_type));
            continue;

        dsc_files = {};
        for file in files.keys():
            if file[-4:] == ".dsc":
                try:
                    dsc = utils.parse_changes(file, 0)
                    dsc_files = utils.build_file_list(dsc, 1)
                except:
                    utils.warn("error processing '%s'; skipping it. [Got %s]" % (file, sys.exc_type));
                    continue;

        # Ensure all the files we've seen aren't deleted
        keys = [];
        for i in (files.keys(), dsc_files.keys(), [changes_filename]):
            keys.extend(i);
        for key in keys:
            if all_files.has_key(key):
                if Options["Verbose"]:
                    print "Skipping, has parents, '%s'." % (key);
                del all_files[key];

    # Anthing left at this stage is not referenced by a .changes (or
    # a .dsc) and should be deleted if old enough.
    for file in all_files.keys():
        if os.stat(file)[stat.ST_MTIME] < delete_date:
            if Options["No-Action"]:
                print "I: Would delete '%s'." % (os.path.basename(file));
            else:
                if Options["Verbose"]:
                    print "Removing '%s' (to '%s')."  % (os.path.basename(file), del_dir);
                remove(file);
        else:
            if Options["Verbose"]:
                print "Skipping, too new, '%s'." % (os.path.basename(file));

################################################################################

def main ():
    global Cnf, Options;

    Cnf = utils.get_conf()

    for i in ["Help", "Incoming", "No-Action", "Verbose" ]:
	if not Cnf.has_key("Shania::Options::%s" % (i)):
	    Cnf["Shania::Options::%s" % (i)] = "";
    if not Cnf.has_key("Shania::Options::Days"):
	Cnf["Shania::Options::Days"] = "14";

    Arguments = [('h',"help","Shania::Options::Help"),
                 ('d',"days","Shania::Options::Days", "IntLevel"),
                 ('i',"incoming","Shania::Options::Incoming", "HasArg"),
                 ('n',"no-action","Shania::Options::No-Action"),
                 ('v',"verbose","Shania::Options::Verbose")];

    apt_pkg.ParseCommandLine(Cnf,Arguments,sys.argv);
    Options = Cnf.SubTree("Shania::Options")

    if Options["Help"]:
	usage();

    init ();

    if Options["Verbose"]:
        print "Processing incoming..."
    flush_orphans();

    if os.path.exists("REJECT") and os.path.isdir("REJECT"):
        if Options["Verbose"]:
            print "Processing incoming/REJECT..."
        os.chdir("REJECT");
        flush_old();

#######################################################################################

if __name__ == '__main__':
    main()
