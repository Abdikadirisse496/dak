#!/usr/bin/env python

# Check for obsolete binary packages
# Copyright (C) 2000, 2001, 2002  James Troup <james@nocrew.org>
# $Id: rene,v 1.14 2002-08-07 17:19:29 troup Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

################################################################################

# ``If you're claiming that's a "problem" that needs to be "fixed",
#   you might as well write some letters to God about how unfair entropy
#   is while you're at it.'' -- 20020802143104.GA5628@azure.humbug.org.au

################################################################################

import commands, pg, os, string, sys, tempfile;
import utils, db_access;
import apt_pkg;

################################################################################

Cnf = None;
projectB = None;

################################################################################

def main ():
    global Cnf, projectB;

    Cnf = utils.get_conf()

    Arguments = [('h',"help","Catherine::Options::Help"),
                 ('V',"version","Catherine::Options::Version"),
                 ('l',"limit", "Catherine::Options::Limit", "HasArg"),
                 ('n',"no-action","Catherine::Options::No-Action"),
                 ('v',"verbose","Catherine::Options::Verbose")];

    apt_pkg.ParseCommandLine(Cnf,Arguments,sys.argv);
    projectB = pg.connect(Cnf["DB::Name"], Cnf["DB::Host"], int(Cnf["DB::Port"]));
    db_access.init(Cnf, projectB);

    bin_pkgs = {};
    miss_src = {};
    src_pkgs = {};
    source_binaries = {};

    suite = "unstable";
    suite_id = db_access.get_suite_id(suite);

    components = Cnf.ValueList("Suite::%s::Components" % (suite));
    for component in components:
        filename = "%s/dists/%s/%s/source/Sources.gz" % (Cnf["Dir::Root"], suite, component);
        # apt_pkg.ParseTagFile needs a real file handle and can't handle a GzipFile instance...
        temp_filename = tempfile.mktemp();
        fd = os.open(temp_filename, os.O_RDWR|os.O_CREAT|os.O_EXCL, 0700);
        os.close(fd);
        (result, output) = commands.getstatusoutput("gunzip -c %s > %s" % (filename, temp_filename));
        if (result != 0):
            sys.stderr.write("Gunzip invocation failed!\n%s\n" % (output));
            sys.exit(result);
        sources = utils.open_file(temp_filename);
        Sources = apt_pkg.ParseTagFile(sources);
        while Sources.Step():
            source = Sources.Section.Find('Package');
            architecture = Sources.Section.Find('Architecture');
            binaries = Sources.Section.Find('Binary');

            # Check for packages built on architectures they shouldn't be.
            if architecture != "any" and architecture != "all":
                architectures = {};
                for arch in string.split(architecture):
                    architectures[string.strip(arch)] = "";
                for binary in string.split(binaries, ','):
                    binary = string.strip(binary);
                    q = projectB.query("SELECT a.arch_string, b.version FROM binaries b, bin_associations ba, architecture a WHERE ba.suite = %s AND ba.bin = b.id AND b.architecture = a.id AND b.package = '%s'" % (suite_id, binary));
                    ql = q.getresult();
                    if not ql:
                        utils.warn("%s lists %s as a binary, but it doesn't seem to exist in %s?" % (source, binary, suite));
                    # Loop around twice; first to get the latest 'valid' version
                    versions = [];
                    for i in q.getresult():
                        arch = i[0];
                        version = i[1];
                        if architectures.has_key(arch):
                            versions.append(version);
                    versions.sort(apt_pkg.VersionCompare);
                    if versions:
                        latest_version = versions.pop()
                    else:
                        latest_version = None;
                    # ... then to check for 'invalid' architectures
                    for i in q.getresult():
                        arch = i[0];
                        version = i[1];
                        if not architectures.has_key(arch):
                            print "[%s]: %s appears for %s (vs. '%s')" % (source, binary, arch, architecture),
                            if not latest_version:
                                print "** mwaap, mwapp!  Ignore me **";
                                continue;
                            if apt_pkg.VersionCompare(latest_version, version) != -1:
                                print "- out of date.",
                            else:
                                print "- current.",
                            print "[%s vs %s (%s)]" % (latest_version, version, arch);

            # Check for duplicated packages and build indices for checking "no source" later
            source_index = component + '/' + source;
            if src_pkgs.has_key(source):
                print " %s is a duplicated source package (%s and %s)" % (source, source_index, src_pkgs[source]);
            src_pkgs[source] = source_index;
            for binary in string.split(binaries, ','):
                binary = string.strip(binary);
                if bin_pkgs.has_key(binary):
                    print " %s is duplicated in %s and %s" % (binary, source, bin_pkgs[binary]);
                bin_pkgs[binary] = source;
            source_binaries[source] = binaries;

        sources.close();
        os.unlink(temp_filename);

    for component in components:
        architectures = filter(utils.real_arch, Cnf.ValueList("Suite::%s::Architectures" % (suite)));
        for architecture in architectures:
            filename = "%s/dists/%s/%s/binary-%s/Packages" % (Cnf["Dir::Root"], suite, component, architecture);
            packages = utils.open_file(filename);
            Packages = apt_pkg.ParseTagFile(packages);
            while Packages.Step():
                package = Packages.Section.Find('Package');
                source = Packages.Section.Find('Source', "");
                if source == "":
                    source = package;
                if string.find(source, "(") != -1:
                    m = utils.re_extract_src_version.match(source)
                    source = m.group(1)
                if not bin_pkgs.has_key(package) and not miss_src.has_key(package):
                    miss_src[package] = 1;
                    print " %s has no source [%s: %s]" % (package, source, source_binaries.get(source, "(source does not exist)"));
            packages.close();

    # Check for packages in experimental obsoleted by versions in unstable
    #
    # [If melanie was callable from python, we could auto-remove these
    #  packages...]

    suite_id = db_access.get_suite_id("unstable");
    q = projectB.query("""
SELECT s.source, s.version AS experimental, s2.version AS unstable
  FROM src_associations sa, source s, source s2, src_associations sa2
  WHERE sa.suite = 1 AND sa2.suite = %d AND sa.source = s.id
   AND sa2.source = s2.id AND s.source = s2.source
   AND versioncmp(s.version, s2.version) < 0""" % (suite_id));
    ql = q.getresult();
    if ql:
        print
        print q

####################################################################################################

if __name__ == '__main__':
    main()
