#!/usr/bin/env python

# Installs Debian packages
# Copyright (C) 2000, 2001  James Troup <james@nocrew.org>
# $Id: katie,v 1.71 2002-02-22 02:19:26 troup Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Originally based on dinstall by Guy Maor <maor@debian.org>

###############################################################################

#    Cartman: "I'm trying to make the best of a bad situation, I don't
#              need to hear crap from a bunch of hippy freaks living in
#              denial.  Screw you guys, I'm going home."
#
#    Kyle: "But Cartman, we're trying to..."
#
#    Cartman: "uhh.. screw you guys... home."

###############################################################################

import FCNTL, fcntl, os, string, sys, time;
import apt_pkg;
import db_access, katie, logging, utils;

###############################################################################

# Globals
katie_version = "$Revision: 1.71 $";

Cnf = None;
Options = None;
Logger = None;
Urgency_Logger = None;
projectB = None;
Katie = None;
pkg = None;

reject_message = "";
changes = None;
dsc = None;
dsc_files = None;
files = None;
Subst = None;

install_count = 0;
install_bytes = 0.0;

###############################################################################

# FIXME: this should go away to some Debian specific file
# FIXME: should die if file already exists

class Urgency_Log:
    "Urgency Logger object"
    def __init__ (self, Cnf):
        "Initialize a new Urgency Logger object"
        self.Cnf = Cnf;
        self.timestamp = time.strftime("%Y%m%d%H%M%S", time.localtime(time.time()));
        # Create the log directory if it doesn't exist
        self.log_dir = Cnf["Dir::UrgencyLogDir"];
        if not os.path.exists(self.log_dir):
            umask = os.umask(00000);
            os.makedirs(self.log_dir, 02775);
        # Open the logfile
        self.log_filename = "%s/.install-urgencies-%s.new" % (self.log_dir, self.timestamp);
        self.log_file = utils.open_file(self.log_filename, 'w');
        self.writes = 0;

    def log (self, source, version, urgency):
        "Log an event"
        self.log_file.write(string.join([source, version, urgency])+'\n');
        self.log_file.flush();
        self.writes = self.writes + 1;

    def close (self):
        "Close a Logger object"
        self.log_file.flush();
        self.log_file.close();
        if self.writes:
            new_filename = "%s/install-urgencies-%s" % (self.log_dir, self.timestamp);
            utils.move(self.log_filename, new_filename);
        else:
            os.unlink(self.log_filename);

###############################################################################

def reject (str, prefix="Rejected: "):
    global reject_message;
    if str:
        reject_message = reject_message + prefix + str + "\n";

# Recheck anything that relies on the database; since that's not
# frozen between accept and katie's run time.

def check():
    for file in files.keys():
        # Check that the source still exists
        if files[file]["type"] == "deb":
            source_version = files[file]["source version"];
            source_package = files[file]["source package"];
            if not changes["architecture"].has_key("source") \
               and not Katie.source_exists(source_package, source_version):
                reject("no source found for %s %s (%s)." % (source_package, source_version, file));

        for suite in changes["distribution"].keys():
            # Check the package is still in the override tables
            if not Katie.in_override_p(files[file]["package"], files[file]["component"], suite, files[file].get("dbtype",""), file):
                reject("%s is NEW for %s." % (file, suite));

            if files[file]["type"] == "deb":
                reject(Katie.check_binaries_against_db(file, suite));
            elif files[file]["type"] == "dsc":
                reject(Katie.check_source_against_db(file));
                (reject_msg, is_in_incoming) = Katie.check_dsc_against_db(file);
                reject(reject_msg);

###############################################################################

def init():
    global Cnf, Options, Katie, projectB, changes, dsc, dsc_files, files, pkg, Subst;

    Cnf = utils.get_conf()

    Arguments = [('a',"automatic","Dinstall::Options::Automatic"),
                 ('h',"help","Dinstall::Options::Help"),
                 ('m',"manual-reject","Dinstall::Options::Manual-Reject", "HasArg"),
                 ('n',"no-action","Dinstall::Options::No-Action"),
                 ('p',"no-lock", "Dinstall::Options::No-Lock"),
                 ('s',"no-mail", "Dinstall::Options::No-Mail"),
                 ('V',"version","Dinstall::Options::Version")];

    for i in ["automatic", "help", "manual-reject", "no-action",
              "no-lock", "no-mail", "version"]:
	if not Cnf.has_key("Dinstall::Options::%s" % (i)):
	    Cnf["Dinstall::Options::%s" % (i)] = "";

    changes_files = apt_pkg.ParseCommandLine(Cnf,Arguments,sys.argv);
    Options = Cnf.SubTree("Dinstall::Options")

    Katie = katie.Katie(Cnf);
    projectB = Katie.projectB;

    changes = Katie.pkg.changes;
    dsc = Katie.pkg.dsc;
    dsc_files = Katie.pkg.dsc_files;
    files = Katie.pkg.files;
    pkg = Katie.pkg;
    Subst = Katie.Subst;

    return changes_files;

###############################################################################

def usage (exit_code=0):
    print """Usage: dinstall [OPTION]... [CHANGES]...
  -a, --automatic           automatic run
  -h, --help                show this help and exit.
  -n, --no-action           don't do anything
  -p, --no-lock             don't check lockfile !! for cron.daily only !!
  -s, --no-mail             don't send any mail
  -V, --version             display the version number and exit"""
    sys.exit(exit_code)

###############################################################################

def action ():
    (summary, short_summary) = Katie.build_summaries();

    (prompt, answer) = ("", "XXX")
    if Options["No-Action"] or Options["Automatic"]:
        answer = 'S'

    if string.find(reject_message, "Rejected") != -1:
        print "REJECT\n" + reject_message,;
        prompt = "[R]eject, Skip, Quit ?";
        if Options["Automatic"]:
            answer = 'R';
    else:
        print "INSTALL\n" + reject_message + summary,;
        prompt = "[I]nstall, Skip, Quit ?";
        if Options["Automatic"]:
            answer = 'I';

    while string.find(prompt, answer) == -1:
        answer = utils.our_raw_input(prompt);
        m = katie.re_default_answer.match(prompt);
        if answer == "":
            answer = m.group(1);
        answer = string.upper(answer[:1]);

    if answer == 'R':
        do_reject ();
    elif answer == 'I':
        install ();
    elif answer == 'Q':
        sys.exit(0)

###############################################################################

# Our reject is not really a reject, but an unaccept, but since a) the
# code for that is non-trivial (reopen bugs, unannounce etc.), b) this
# should be exteremly rare, for now we'll go with whining at our admin
# folks...

def do_reject ():
    Subst["__REJECTOR_ADDRESS__"] = Cnf["Dinstall::MyEmailAddress"];
    Subst["__REJECT_MESSAGE__"] = reject_message;
    Subst["__CC__"] = "Cc: " + Cnf["Dinstall::MyEmailAddress"];
    reject_mail_message = utils.TemplateSubst(Subst,utils.open_file(Cnf["Dir::TemplatesDir"]+"/katie.unaccept").read());

    # Write the rejection email out as the <foo>.reason file
    reason_filename = os.path.basename(pkg.changes_file[:-8]) + ".reason";
    reject_filename = Cnf["Dir::QueueRejectDir"] + '/' + reason_filename;
    # If we fail here someone is probably trying to exploit the race
    # so let's just raise an exception ...
    if os.path.exists(reject_filename):
        os.unlink(reject_filename);
    fd = os.open(reject_filename, os.O_RDWR|os.O_CREAT|os.O_EXCL, 0644);
    os.write(fd, reject_mail_message);
    os.close(fd);

    utils.send_mail (reject_mail_message, "");
    Logger.log(["unaccepted", pkg.changes_file]);

###############################################################################

def install ():
    global install_count, install_bytes;

    print "Installing."

    Logger.log(["installing changes",pkg.changes_file]);

    # Begin a transaction; if we bomb out anywhere between here and the COMMIT WORK below, the DB will not be changed.
    projectB.query("BEGIN WORK");

    # Add the .dsc file to the DB
    for file in files.keys():
        if files[file]["type"] == "dsc":
            package = dsc["source"]
            version = dsc["version"]  # NB: not files[file]["version"], that has no epoch
            maintainer = dsc["maintainer"]
            maintainer = string.replace(maintainer, "'", "\\'")
            maintainer_id = db_access.get_or_set_maintainer_id(maintainer);
            fingerprint_id = db_access.get_or_set_fingerprint_id(dsc["fingerprint"]);
            install_date = time.strftime("%Y-%m-%d", time.localtime(time.time()));
            filename = files[file]["pool name"] + file;
            dsc_location_id = files[file]["location id"];
            if not files[file]["files id"]:
                files[file]["files id"] = db_access.set_files_id (filename, files[file]["size"], files[file]["md5sum"], dsc_location_id)
            projectB.query("INSERT INTO source (source, version, maintainer, file, install_date, sig_fpr) VALUES ('%s', '%s', %d, %d, '%s', %s)"
                           % (package, version, maintainer_id, files[file]["files id"], install_date, fingerprint_id));

            for suite in changes["distribution"].keys():
                suite_id = db_access.get_suite_id(suite);
                projectB.query("INSERT INTO src_associations (suite, source) VALUES (%d, currval('source_id_seq'))" % (suite_id))

            # Add the source files to the DB (files and dsc_files)
            projectB.query("INSERT INTO dsc_files (source, file) VALUES (currval('source_id_seq'), %d)" % (files[file]["files id"]));
            for dsc_file in dsc_files.keys():
                filename = files[file]["pool name"] + dsc_file;
                # If the .orig.tar.gz is already in the pool, it's
                # files id is stored in dsc_files by check_dsc().
                files_id = dsc_files[dsc_file].get("files id", None);
                if files_id == None:
                    files_id = db_access.get_files_id(filename, dsc_files[dsc_file]["size"], dsc_files[dsc_file]["md5sum"], dsc_location_id);
                # FIXME: needs to check for -1/-2 and or handle exception
                if files_id == None:
                    files_id = db_access.set_files_id (filename, dsc_files[dsc_file]["size"], dsc_files[dsc_file]["md5sum"], dsc_location_id);
                projectB.query("INSERT INTO dsc_files (source, file) VALUES (currval('source_id_seq'), %d)" % (files_id));

    # Add the .deb files to the DB
    for file in files.keys():
        if files[file]["type"] == "deb":
            package = files[file]["package"]
            version = files[file]["version"]
            maintainer = files[file]["maintainer"]
            maintainer = string.replace(maintainer, "'", "\\'")
            maintainer_id = db_access.get_or_set_maintainer_id(maintainer);
            fingerprint_id = db_access.get_or_set_fingerprint_id(changes["fingerprint"]);
            architecture = files[file]["architecture"]
            architecture_id = db_access.get_architecture_id (architecture);
            type = files[file]["dbtype"];
            dsc_component = files[file]["component"]
            source = files[file]["source package"]
            source_version = files[file]["source version"];
            filename = files[file]["pool name"] + file;
            if not files[file]["files id"]:
                files[file]["files id"] = db_access.set_files_id (filename, files[file]["size"], files[file]["md5sum"], files[file]["location id"])
            source_id = db_access.get_source_id (source, source_version);
            if source_id:
                projectB.query("INSERT INTO binaries (package, version, maintainer, source, architecture, file, type, sig_fpr) VALUES ('%s', '%s', %d, %d, %d, %d, '%s', %d)"
                               % (package, version, maintainer_id, source_id, architecture_id, files[file]["files id"], type, fingerprint_id));
            else:
                projectB.query("INSERT INTO binaries (package, version, maintainer, architecture, file, type) VALUES ('%s', '%s', %d, %d, %d, '%s', %d)"
                               % (package, version, maintainer_id, architecture_id, files[file]["files id"], type, fingerprint_id));
            for suite in changes["distribution"].keys():
                suite_id = db_access.get_suite_id(suite);
                projectB.query("INSERT INTO bin_associations (suite, bin) VALUES (%d, currval('binaries_id_seq'))" % (suite_id));

    # If the .orig.tar.gz is in a legacy directory we need to poolify
    # it, so that apt-get source (and anything else that goes by the
    # "Directory:" field in the Sources.gz file) works.
    orig_tar_id = Katie.pkg.orig_tar_id;
    orig_tar_location = Katie.pkg.orig_tar_location;
    legacy_source_untouchable = Katie.pkg.legacy_source_untouchable;
    if orig_tar_id != None and orig_tar_location == "legacy":
        q = projectB.query("SELECT DISTINCT ON (f.id) l.path, f.filename, f.id as files_id, df.source, df.id as dsc_files_id, f.size, f.md5sum FROM files f, dsc_files df, location l WHERE df.source IN (SELECT source FROM dsc_files WHERE file = %s) AND f.id = df.file AND l.id = f.location AND (l.type = 'legacy' OR l.type = 'legacy-mixed')" % (orig_tar_id));
        qd = q.dictresult();
        for qid in qd:
            # Is this an old upload superseded by a newer -sa upload?  (See check_dsc() for details)
            if legacy_source_untouchable.has_key(qid["files_id"]):
                continue;
            # First move the files to the new location
            legacy_filename = qid["path"]+qid["filename"];
            pool_location = utils.poolify (changes["source"], files[file]["component"]);
            pool_filename = pool_location + os.path.basename(qid["filename"]);
            destination = Cnf["Dir::PoolDir"] + pool_location
            utils.move(legacy_filename, destination);
            # Then Update the DB's files table
            q = projectB.query("UPDATE files SET filename = '%s', location = '%s' WHERE id = '%s'" % (pool_filename, dsc_location_id, qid["files_id"]));

    # If this is a sourceful diff only upload that is moving non-legacy
    # cross-component we need to copy the .orig.tar.gz into the new
    # component too for the same reasons as above.
    #
    if changes["architecture"].has_key("source") and orig_tar_id != None and \
       orig_tar_location != "legacy" and orig_tar_location != dsc_location_id:
        q = projectB.query("SELECT l.path, f.filename, f.size, f.md5sum FROM files f, location l WHERE f.id = %s AND f.location = l.id" % (orig_tar_id));
        ql = q.getresult()[0];
        old_filename = ql[0] + ql[1];
        file_size = ql[2];
        file_md5sum = ql[3];
        new_filename = utils.poolify (changes["source"], dsc_component) + os.path.basename(old_filename);
        new_files_id = db_access.get_files_id(new_filename, file_size, file_md5sum, dsc_location_id);
        if new_files_id == None:
            utils.copy(old_filename, Cnf["Dir::PoolDir"] + new_filename);
            new_files_id = db_access.set_files_id(new_filename, file_size, file_md5sum, dsc_location_id);
            projectB.query("UPDATE dsc_files SET file = %s WHERE source = %s AND file = %s" % (new_files_id, source_id, orig_tar_id));

    # Install the files into the pool
    for file in files.keys():
        destination = Cnf["Dir::PoolDir"] + files[file]["pool name"] + file
        utils.move (file, destination)
        Logger.log(["installed", file, files[file]["type"], files[file]["size"], files[file]["architecture"]]);
        install_bytes = install_bytes + float(files[file]["size"])

    # Copy the .changes file across for suite which need it.
    for suite in changes["distribution"].keys():
        if Cnf.has_key("Suite::%s::CopyChanges" % (suite)):
            utils.copy (pkg.changes_file, Cnf["Dir::RootDir"] + Cnf["Suite::%s::CopyChanges" % (suite)]);

    projectB.query("COMMIT WORK");

    # Move the .changes into the 'done' directory
    try:
        utils.move (pkg.changes_file, os.path.join(Cnf["Dir::QueueDoneDir"], os.path.basename(pkg.changes_file)));
    except:
        utils.warn("couldn't move changes file '%s' to DONE directory. [Got %s]" % (os.path.basename(pkg.changes_file), sys.exc_type));

    os.unlink(Katie.pkg.changes_file[:-8]+".katie");

    if changes["architecture"].has_key("source"):
        Urgency_Logger.log(dsc["source"], dsc["version"], changes["urgency"]);

    install_count = install_count + 1;

################################################################################

def process_it (changes_file):
    # Absolutize the filename to avoid the requirement of being in the
    # same directory as the .changes file.
    pkg.changes_file = os.path.abspath(changes_file);

    # And since handling of installs to stable munges with the CWD;
    # save and restore it.
    pkg.directory = os.getcwd();

    Katie.init_vars();
    Katie.update_vars();
    Katie.update_subst();
    check();
    action();

    # Restore CWD
    os.chdir(pkg.directory);

###############################################################################

def main():
    global projectB, Logger, Urgency_Logger;

    changes_files = init();

    if Options["Help"]:
        usage();

    if Options["Version"]:
        print "katie %s" % (katie_version);
        sys.exit(0);

    # -n/--dry-run invalidates some other options which would involve things happening
    if Options["No-Action"]:
        Options["Automatic"] = "";

    # Check that we aren't going to clash with the daily cron job

    if not Options["No-Action"] and os.path.exists("%s/Archive_Maintenance_In_Progress" % (Cnf["Dir::RootDir"])) and not Options["No-Lock"]:
        utils.fubar("Archive maintenance in progress.  Try again later.");

    # Obtain lock if not in no-action mode and initialize the log

    if not Options["No-Action"]:
        lock_fd = os.open(Cnf["Dinstall::LockFile"], os.O_RDWR | os.O_CREAT);
        fcntl.lockf(lock_fd, FCNTL.F_TLOCK);
        Logger = Katie.Logger = logging.Logger(Cnf, "katie");
        Urgency_Logger = Urgency_Log(Cnf);

    # Initialize the substitution template mapping global
    bcc = "X-Katie: %s" % (katie_version);
    if Cnf.has_key("Dinstall::Bcc"):
        Subst["__BCC__"] = bcc + "\nBcc: %s" % (Cnf["Dinstall::Bcc"]);
    else:
        Subst["__BCC__"] = bcc;
    Subst["__STABLE_REJECTOR__"] = Cnf["Dinstall::StableRejector"];

    # Sort the .changes files so that we process sourceful ones first
    changes_files.sort(utils.changes_compare);

    # Process the changes files
    for changes_file in changes_files:
        print "\n" + changes_file;
        process_it (changes_file);

    if install_count:
        sets = "set"
        if install_count > 1:
            sets = "sets"
        sys.stderr.write("Installed %d package %s, %s.\n" % (install_count, sets, utils.size_type(int(install_bytes))));
        Logger.log(["total",install_count,install_bytes]);

    if not Options["No-Action"]:
        Logger.close();
        Urgency_Logger.close();

if __name__ == '__main__':
    main()

